#!/usr/bin/env bash
# mew - Multiple Environment Worktrees
# Git worktree + Docker Compose で並行開発するための汎用 CLI（単一ファイル）
set -euo pipefail

VERSION="0.1.0"

# --- 前提チェック ---
need_cmd() {
  if ! command -v "$1" >/dev/null 2>&1; then
    echo "mew: 必要なコマンドが見つかりません: $1" >&2
    echo "mew: git と Docker をインストールしてから再実行してください。" >&2
    exit 1
  fi
}

# --- プロジェクト・main worktree の検出 ---
find_project_root() {
  local dir="${1:-.}"
  dir="$(cd "$dir" && pwd)"
  if [[ -d "$dir/.git" ]]; then
    echo "$dir"
    return 0
  fi
  if git -C "$dir" rev-parse --show-toplevel 2>/dev/null; then
    return 0
  fi
  echo "$dir"
}

find_main_worktree_dir() {
  local line path
  while IFS= read -r line; do
    if [[ "$line" == worktree\ * ]]; then
      path="${line#worktree }"
      if [[ -d "$path/.git" ]]; then
        echo "$path"
        return 0
      fi
    fi
  done < <(git worktree list --porcelain 2>/dev/null || true)
  return 1
}

# --- 推測: docker-compose.yml と .env から ---
infer_main_dir() {
  local root="$1"
  local main
  main="$(find_main_worktree_dir 2>/dev/null || true)"
  if [[ -n "${main:-}" ]]; then
    echo "$main"
    return
  fi
  if [[ -d "$root/.git" ]]; then
    echo "$root"
    return
  fi
  echo "$root"
}

infer_db_name_prefix() {
  local main_dir="$1"
  local compose="$main_dir/docker-compose.yml"
  local prefix
  if [[ -f "$compose" ]]; then
    prefix="$(grep -E 'POSTGRES_DB:|POSTGRES_DB\s*:' "$compose" 2>/dev/null | head -1 | sed -E 's/.*\$\{POSTGRES_DB:-([^}]+)\}.*/\1/; s/.*POSTGRES_DB:\s*([^[:space:]]+).*/\1/; s/[" ]//g')" || true
    if [[ -n "${prefix:-}" ]]; then
      echo "$prefix"
      return
    fi
  fi
  echo "$(basename "$main_dir" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9]+/_/g; s/^_+|_+$//g')"
}

infer_env_file() {
  local main_dir="$1"
  if [[ -n "${MEW_ENV_FILE:-}" ]]; then
    echo "$MEW_ENV_FILE"
    return
  fi
  if [[ -f "$main_dir/app/.env" ]]; then
    echo "$main_dir/app/.env"
    return
  fi
  if [[ -f "$main_dir/.env" ]]; then
    echo "$main_dir/.env"
    return
  fi
  echo "$main_dir/.env"
}

infer_worktree_volume_mount() {
  local main_dir="$1"
  local compose="$main_dir/docker-compose.yml"
  if [[ -n "${MEW_WORKTREE_VOLUME:-}" ]]; then
    echo "${MEW_WORKTREE_VOLUME}"
    return
  fi
  if [[ -f "$compose" ]]; then
    local line
    if command -v python3 >/dev/null 2>&1; then
      line="$(python3 - "$compose" <<'PY'
import re
import sys

path = sys.argv[1]
in_web = False
for raw in open(path, encoding="utf-8"):
    if re.match(r'^\s+web:\s*$', raw):
        in_web = True
        continue
    if in_web and re.match(r'^\s{2}[A-Za-z].*:', raw):
        break
    if in_web and re.match(r'^\s+-\s+\./', raw):
        line = raw.strip()
        if line.startswith("- "):
            line = line[2:]
        print(line)
        break
PY
)"
    elif command -v python >/dev/null 2>&1; then
      line="$(python - "$compose" <<'PY'
import re
import sys

path = sys.argv[1]
in_web = False
for raw in open(path):
    if re.match(r'^\s+web:\s*$', raw):
        in_web = True
        continue
    if in_web and re.match(r'^\s{2}[A-Za-z].*:', raw):
        break
    if in_web and re.match(r'^\s+-\s+\./', raw):
        line = raw.strip()
        if line.startswith("- "):
            line = line[2:]
        print(line)
        break
PY
)"
    else
      line="$(awk '/^[[:space:]]+web:[[:space:]]*$/,/^  [a-z]/ { if ($0 ~ /^[[:space:]]+-[[:space:]]+\\./) { print; exit } }' "$compose" | head -1)"
    fi
    if [[ -n "$line" ]]; then
      # "./app:/app" -> "${WORKTREE_DIR}/app:/app"
      local host_path container_path
      host_path="${line%%:*}"
      container_path="${line#*:}"
      host_path="${host_path#./}"
      if [[ -n "$host_path" && -n "$container_path" ]]; then
        echo "\${WORKTREE_DIR:-.}/$host_path:$container_path"
        return
      fi
    fi
  fi
  echo '${WORKTREE_DIR:-.}:/app'
}

# --- スラグ・DB名・ポート ---
sanitize_slug() {
  local s="${1:-}"
  s="$(echo "$s" | tr '[:upper:]' '[:lower:]')"
  s="$(echo "$s" | sed -E 's/[^a-z0-9]+/_/g; s/^_+|_+$//g; s/__+/_/g')"
  if [[ -z "$s" ]]; then
    s="wt"
  fi
  if [[ "$s" =~ ^[0-9] ]]; then
    s="wt_${s}"
  fi
  echo "$s"
}

abs_path() {
  local base="$1"
  local rel="$2"
  if command -v python3 >/dev/null 2>&1; then
    BASE="$base" REL="$rel" python3 - <<'PY'
import os
base = os.environ.get("BASE", "")
rel = os.environ.get("REL", "")
print(os.path.abspath(os.path.join(base, rel)))
PY
    return
  fi
  if command -v python >/dev/null 2>&1; then
    BASE="$base" REL="$rel" python - <<'PY'
import os
base = os.environ.get("BASE", "")
rel = os.environ.get("REL", "")
print(os.path.abspath(os.path.join(base, rel)))
PY
    return
  fi
  echo "${base%/}/$rel"
}

validate_db_name() {
  local name="$1"
  if [[ ! "$name" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]; then
    echo "mew: 不正なDB名です（英字・数字・アンダースコアのみ使用可能）: $name" >&2
    exit 1
  fi
}

db_name_for_slug() {
  local slug="$1"
  local prefix="${2:-}"
  local name="${prefix}_${slug}"
  if ((${#name} > 60)); then
    local hash
    hash="$(echo -n "$name" | cksum | awk '{print $1}')"
    name="${name:0:45}_${hash}"
    name="${name:0:60}"
  fi
  echo "$name"
}

web_port_for_slug() {
  local slug="$1"
  local hash
  hash="$(echo -n "$slug" | cksum | awk '{print $1}')"
  echo "$((3100 + (hash % 900)))"
}

is_port_available() {
  local port="$1"
  if command -v python3 >/dev/null 2>&1; then
    python3 - "$port" <<'PY'
import socket
import sys

port = int(sys.argv[1])
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
try:
    s.bind(("0.0.0.0", port))
except OSError:
    sys.exit(1)
finally:
    s.close()
sys.exit(0)
PY
    return $?
  fi
  if command -v python >/dev/null 2>&1; then
    python - "$port" <<'PY'
import socket
import sys

port = int(sys.argv[1])
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
try:
    s.bind(("0.0.0.0", port))
except OSError:
    sys.exit(1)
finally:
    s.close()
sys.exit(0)
PY
    return $?
  fi
  if command -v lsof >/dev/null 2>&1; then
    if lsof -iTCP:"$port" -sTCP:LISTEN >/dev/null 2>&1; then
      return 1
    fi
    return 0
  fi
  return 0
}

pick_available_port() {
  local port="$1"
  local max_tries=50
  local i=0
  while ((i < max_tries)); do
    if is_port_available "$port"; then
      echo "$port"
      return
    fi
    port="$((port + 1))"
    i="$((i + 1))"
  done
  echo "$port"
}

# --- 安全な .env パーサー（source の代替。変数定義行のみを export する）---
safe_load_env() {
  local env_file="$1"
  local line key value
  while IFS= read -r line || [[ -n "$line" ]]; do
    # 先頭の空白を除去
    line="${line#"${line%%[![:space:]]*}"}"
    # コメント行・空行をスキップ
    [[ -z "$line" || "$line" == \#* ]] && continue
    # 'export ' プレフィックスを除去
    line="${line#export }"
    line="${line#"${line%%[![:space:]]*}"}"
    # KEY=VALUE 形式のみ受け付ける
    if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*) ]]; then
      key="${BASH_REMATCH[1]}"
      value="${BASH_REMATCH[2]}"
      # 末尾の空白を除去
      value="${value%"${value##*[![:space:]]}"}"
      # 囲みクォートを除去
      if [[ "$value" =~ ^\"(.*)\"$ ]]; then
        value="${BASH_REMATCH[1]}"
      elif [[ "$value" =~ ^\'(.*)\'$ ]]; then
        value="${BASH_REMATCH[1]}"
      fi
      export "$key=$value"
    fi
  done < "$env_file"
}

# --- 現在の worktree 向けの値を算出（env / compose / build で共通利用）---
mew_resolve_context() {
  local root="${1:-.}"
  root="$(cd "$root" && pwd)"
  MEW_PROJECT_ROOT="$root"
  MEW_MAIN_DIR="$(infer_main_dir "$root")"
  MEW_MAIN_DIR="$(cd "$MEW_MAIN_DIR" && pwd)"
  MEW_DB_NAME_PREFIX="$(infer_db_name_prefix "$MEW_MAIN_DIR")"
  MEW_ENV_FILE="$(infer_env_file "$MEW_MAIN_DIR")"
  MEW_WORKTREE_VOLUME_MOUNT="$(infer_worktree_volume_mount "$MEW_MAIN_DIR")"
  MEW_DB_SERVICE="${MEW_DB_SERVICE:-db}"
  MEW_WEB_SERVICE="${MEW_WEB_SERVICE:-web}"

  local target_dir="${2:-$root}"
  target_dir="$(cd "$target_dir" && pwd)"
  MEW_TARGET_WORKTREE_DIR="$target_dir"
  MEW_TARGET_BASENAME="$(basename "$target_dir")"
  MEW_WORKTREE_SLUG="$(sanitize_slug "$MEW_TARGET_BASENAME")"
  MEW_IS_MAIN=false
  if [[ "$target_dir" == "$MEW_MAIN_DIR" ]]; then
    MEW_IS_MAIN=true
    if [[ -n "${MEW_WORKTREE_DB_NAME_OVERRIDE:-}" ]]; then
      MEW_WORKTREE_DB_NAME="$MEW_WORKTREE_DB_NAME_OVERRIDE"
    else
      MEW_WORKTREE_DB_NAME="$MEW_DB_NAME_PREFIX"
    fi
    MEW_WT_PROJECT="$(sanitize_slug "$(basename "$MEW_MAIN_DIR")")"
  else
    if [[ -n "${MEW_WORKTREE_DB_NAME_OVERRIDE:-}" ]]; then
      MEW_WORKTREE_DB_NAME="$MEW_WORKTREE_DB_NAME_OVERRIDE"
    else
      MEW_WORKTREE_DB_NAME="$(db_name_for_slug "$MEW_WORKTREE_SLUG" "$MEW_DB_NAME_PREFIX")"
    fi
    if [[ -n "${MEW_WT_PROJECT_OVERRIDE:-}" ]]; then
      MEW_WT_PROJECT="$MEW_WT_PROJECT_OVERRIDE"
    else
      MEW_WT_PROJECT="$MEW_WORKTREE_SLUG"
    fi
  fi
  if [[ -n "${MEW_WEB_PORT:-}" ]]; then
    MEW_WEB_PORT="$MEW_WEB_PORT"
  else
    MEW_WEB_PORT="$(web_port_for_slug "$MEW_WORKTREE_SLUG")"
    MEW_WEB_PORT="$(pick_available_port "$MEW_WEB_PORT")"
  fi
  validate_db_name "$MEW_WORKTREE_DB_NAME"
}

# --- compose YAML を一時ファイルに書き出す（パイプだと stdin を塞ぎ対話コマンドが使えないため）---
_mew_compose_file=""
_mew_write_compose() {
  _mew_compose_file="$(umask 077 && mktemp "${TMPDIR:-/tmp}/mew-compose-XXXXXX.yml")"
  mew_emit_compose_yml "$1" "$2" > "$_mew_compose_file"
}
_mew_cleanup_compose() {
  [[ -n "${_mew_compose_file:-}" ]] && rm -f "$_mew_compose_file"
  _mew_compose_file=""
}

# --- worktree 用 compose YAML を stdout に出力（ファイルは作らない）---
mew_emit_compose_yml() {
  local main_dir="$1"
  local worktree_volume="${2:-}"
  [[ -z "$worktree_volume" ]] && worktree_volume='${WORKTREE_DIR:-.}:/app'
  local web_svc="${MEW_WEB_SERVICE:-web}"
  cat <<YAML
services:
  ${web_svc}:
    build:
      context: \${MEW_BUILD_CONTEXT:-.}
      target: \${MEW_BUILD_TARGET:-base}
    ports:
      - "127.0.0.1:\${WEB_PORT:-3000}:3000"
    env_file:
      - \${ENV_FILE:-.env}
    environment:
      NODE_ENV: development
      DATABASE_URL: \${DATABASE_URL}
      NEXTAUTH_URL: \${NEXTAUTH_URL:-http://localhost:\${WEB_PORT}}
      S3_ENDPOINT: \${S3_ENDPOINT:-http://host.docker.internal:\${MINIO_PORT:-19000}}
      WORKTREE_DIR: \${WORKTREE_DIR}
      CHOKIDAR_USEPOLLING: "1"
      WATCHPACK_POLLING: "true"
      WATCHPACK_POLLING_INTERVAL: "1000"
    volumes:
      - ${worktree_volume}
      - web-node_modules:/app/node_modules
      - web-pnpm-store:/pnpm-store
    command: >
      sh -c "pnpm install --frozen-lockfile &&
             if [ \"\${DEV_TURBO:-0}\" = \"1\" ]; then
               pnpm dev --turbo;
             else
               pnpm dev;
             fi"

volumes:
  web-node_modules:
  web-pnpm-store:

YAML
}

# --- サブコマンド: ヘルプ ---
cmd_help() {
  cat <<'EOF'
mew - Multiple Environment Worktrees

Git worktree と Docker Compose で並行開発するための汎用 CLI。

使い方:
  mew [サブコマンド] [オプション...]

サブコマンド:
  build     対話型: worktree 作成 → 各 worktree で web 起動
  rm        worktree の web 停止・DB 削除
  rm --all  main で全 worktree を削除

詳細: https://github.com/nekojarashi/mew
EOF
}

# --- サブコマンド: compose ---
cmd_compose() {
  local root
  root="$(find_project_root .)"
  mew_resolve_context "$root" "$root"
  if [[ ! -f "$MEW_ENV_FILE" ]]; then
    echo "mew: ENV_FILE が見つかりません: $MEW_ENV_FILE" >&2
    exit 1
  fi
  local db_user="${POSTGRES_USER:-app_user}"
  local db_pass="${POSTGRES_PASSWORD:-app_pass}"
  local db_port="${DB_PORT:-5433}"
  local database_url="postgresql://${db_user}:${db_pass}@host.docker.internal:${db_port}/${MEW_WORKTREE_DB_NAME}"
  local nextauth_url="${NEXTAUTH_URL:-http://localhost:${MEW_WEB_PORT}}"
  _mew_write_compose "$MEW_MAIN_DIR" "$MEW_WORKTREE_VOLUME_MOUNT"
  local rc=0
  (
    cd "$MEW_MAIN_DIR" && \
    export COMPOSE_PROJECT_NAME="$MEW_WT_PROJECT" \
           WORKTREE_DIR="$MEW_TARGET_WORKTREE_DIR" \
           ENV_FILE="$MEW_ENV_FILE" \
           WEB_PORT="$MEW_WEB_PORT" \
           DATABASE_URL="$database_url" \
           NEXTAUTH_URL="$nextauth_url" \
           MEW_WEB_SERVICE="$MEW_WEB_SERVICE" \
           MEW_BUILD_CONTEXT="$MEW_MAIN_DIR" && \
    docker compose -f "$_mew_compose_file" "$@"
  ) || rc=$?
  _mew_cleanup_compose
  return $rc
}

# --- サブコマンド: build（worktree 作成 + web 起動）---
cmd_build() {
  local root
  root="$(find_project_root .)"
  need_cmd git
  need_cmd docker
  if [[ ! -d "$root/.git" ]]; then
    echo "mew: git リポジトリのルートで実行してください。" >&2
    exit 1
  fi
  mew_resolve_context "$root" "$root"
  if [[ "$MEW_IS_MAIN" != "true" ]]; then
    echo "mew build: main worktree で実行してください。" >&2
    exit 1
  fi
  if [[ ! -f "$MEW_ENV_FILE" ]]; then
    echo "mew: ENV_FILE が見つかりません: $MEW_ENV_FILE" >&2
    exit 1
  fi
  local main_compose="$MEW_MAIN_DIR/docker-compose.yml"
  if [[ ! -f "$main_compose" ]]; then
    echo "mew: 見つかりません: $main_compose" >&2
    exit 1
  fi

  # 対話: ブランチ名
  local branches=()
  if (($# > 0)); then
    branches=("$@")
  else
    if [[ "${MEW_NON_INTERACTIVE:-}" == "1" ]]; then
      echo "mew build: 非対話時はブランチ名を引数で指定してください。" >&2
      exit 1
    fi
    local line
    read -r -p "作成/起動したいブランチ名をスペース区切りで入力: " line
    set -f
    # shellcheck disable=SC2206
    branches=($line)
    set +f
  fi
  if ((${#branches[@]} == 0)); then
    echo "mew: ブランチ名が空です。" >&2
    exit 1
  fi

  local prefix="${MEW_PREFIX:-../$(basename "$MEW_MAIN_DIR")-}"
  local base_ref
  base_ref="$(git -C "$MEW_MAIN_DIR" rev-parse --abbrev-ref HEAD)"

  for br in "${branches[@]}"; do
    local slug wt_dir wt_dir_abs
    slug="$(sanitize_slug "$br")"
    wt_dir="${prefix}${slug}"
    wt_dir_abs="$(abs_path "$MEW_MAIN_DIR" "$wt_dir")"
    local existing_wt_for_branch
    existing_wt_for_branch="$(git worktree list --porcelain 2>/dev/null | awk -v br="refs/heads/$br" '
      $1 == "worktree" { path = $2 }
      $1 == "branch" && $2 == br { print path; exit }
    ')"
    if [[ -n "$existing_wt_for_branch" ]]; then
      echo "[mew] already exists for branch: $br ($existing_wt_for_branch)"
      wt_dir_abs="$existing_wt_for_branch"
    else
      if git worktree list --porcelain 2>/dev/null | grep -Fq "worktree $wt_dir_abs"; then
        echo "[mew] already exists: $wt_dir_abs"
      else
        if [[ -e "$wt_dir_abs" ]]; then
          echo "mew: ディレクトリが既に存在します（worktree 未登録のためスキップ）: $wt_dir_abs" >&2
          continue
        fi
        if git show-ref --verify --quiet "refs/heads/$br" 2>/dev/null; then
          git worktree add "$wt_dir_abs" "$br"
        else
          git worktree add -b "$br" "$wt_dir_abs" "$base_ref"
        fi
      fi
    fi
    # この worktree で web 起動
    (MEW_INVOKED_FROM_BUILD=1 mew_build_one "$wt_dir_abs")
  done
  echo "[mew] done"
}

mew_build_one() {
  local target_dir="$1"
  target_dir="$(cd "$target_dir" && pwd)"
  if [[ "${MEW_INVOKED_FROM_BUILD:-}" == "1" && -z "${MEW_WEB_PORT_OVERRIDE:-}" ]]; then
    unset MEW_WEB_PORT
  fi
  mew_resolve_context "$MEW_MAIN_DIR" "$target_dir"
  local resolved_wt_project="$MEW_WT_PROJECT"
  local resolved_wt_db_name="$MEW_WORKTREE_DB_NAME"
  # main の .env を読み込み（POSTGRES_* 等を利用するため）
  if [[ -f "$MEW_ENV_FILE" ]]; then
    safe_load_env "$MEW_ENV_FILE"
  fi
  if [[ -z "${MEW_WT_PROJECT_OVERRIDE:-}" ]]; then
    MEW_WT_PROJECT="$resolved_wt_project"
  fi
  if [[ -z "${MEW_WORKTREE_DB_NAME_OVERRIDE:-}" ]]; then
    MEW_WORKTREE_DB_NAME="$resolved_wt_db_name"
  fi
  # .env が MEW_WORKTREE_DB_NAME を上書きしている可能性があるため再検証
  validate_db_name "$MEW_WORKTREE_DB_NAME"
  local db_user="${POSTGRES_USER:-app_user}"
  local db_pass="${POSTGRES_PASSWORD:-app_pass}"
  local db_port="${DB_PORT:-5433}"
  local database_url="postgresql://${db_user}:${db_pass}@host.docker.internal:${db_port}/${MEW_WORKTREE_DB_NAME}"
  local nextauth_url="http://localhost:${MEW_WEB_PORT}"
  local clone_source="${DB_CLONE_SOURCE:-$MEW_DB_NAME_PREFIX}"
  validate_db_name "$clone_source"
  local env_file="$MEW_ENV_FILE"
  local refresh_db="${MEW_DB_REFRESH:-}"
  if [[ -z "$refresh_db" && "${MEW_INVOKED_FROM_BUILD:-}" == "1" ]]; then
    refresh_db="1"
  fi
  if [[ "$MEW_WORKTREE_DB_NAME" == "$clone_source" ]]; then
    if [[ "$refresh_db" == "1" ]]; then
      echo "mew: refresh db はコピー元と同名のため無効化します: $MEW_WORKTREE_DB_NAME" >&2
    fi
    refresh_db="0"
  fi

  echo "[mew] MAIN_DIR=$MEW_MAIN_DIR TARGET=$target_dir WT_PROJECT=$MEW_WT_PROJECT WEB_PORT=$MEW_WEB_PORT DB=$MEW_WORKTREE_DB_NAME"
  if [[ "$refresh_db" == "1" ]]; then
    echo "[mew] refresh db: $MEW_WORKTREE_DB_NAME from $clone_source"
  fi
  (cd "$MEW_MAIN_DIR" && docker compose up -d "$MEW_DB_SERVICE")
  local db_container_id
  db_container_id="$(cd "$MEW_MAIN_DIR" && docker compose ps -q "$MEW_DB_SERVICE")"
  if [[ -z "${db_container_id:-}" ]]; then
    echo "mew: DB コンテナの起動に失敗しました。" >&2
    exit 1
  fi
  # DB 作成（無ければ）
  docker exec -i \
    -e "MEW_DB_NAME=$MEW_WORKTREE_DB_NAME" \
    -e "MEW_CLONE_FROM=$clone_source" \
    -e "MEW_REFRESH_DB=$refresh_db" \
    "$db_container_id" sh -l <<'DBSCRIPT'
set -e
EXISTS=$(psql -U "$POSTGRES_USER" -d postgres -tAc "SELECT 1 FROM pg_database WHERE datname='$MEW_DB_NAME'")
if [ "$EXISTS" = "1" ] && [ "$MEW_REFRESH_DB" = "1" ]; then
  psql -U "$POSTGRES_USER" -d postgres -v ON_ERROR_STOP=1 -c "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname='$MEW_DB_NAME' AND pid <> pg_backend_pid();"
  psql -U "$POSTGRES_USER" -d postgres -v ON_ERROR_STOP=1 -c "DROP DATABASE \"$MEW_DB_NAME\";"
  EXISTS="0"
fi
if [ "$EXISTS" != "1" ]; then
  psql -U "$POSTGRES_USER" -d postgres -v ON_ERROR_STOP=1 -c "CREATE DATABASE \"$MEW_DB_NAME\";"
  SRC_EXISTS=$(psql -U "$POSTGRES_USER" -d postgres -tAc "SELECT 1 FROM pg_database WHERE datname='$MEW_CLONE_FROM'")
  if [ "$SRC_EXISTS" = "1" ]; then
    pg_dump -U "$POSTGRES_USER" -d "$MEW_CLONE_FROM" -Fc | pg_restore -U "$POSTGRES_USER" -d "$MEW_DB_NAME" --no-owner --no-privileges || true
  fi
fi
DBSCRIPT
  # マイグレーション（MEW_MIGRATE_CMD があれば実行）
  # 注意: MEW_MIGRATE_CMD はそのまま sh -c に渡される（設計上の仕様）。
  # 信頼できない環境変数を受け入れないこと。
  _mew_write_compose "$MEW_MAIN_DIR" "$MEW_WORKTREE_VOLUME_MOUNT"
  if [[ -n "${MEW_MIGRATE_CMD:-}" ]]; then
    (
      cd "$MEW_MAIN_DIR" && \
      export COMPOSE_PROJECT_NAME="$MEW_WT_PROJECT" WORKTREE_DIR="$target_dir" ENV_FILE="$env_file" \
             WEB_PORT="$MEW_WEB_PORT" DATABASE_URL="$database_url" NEXTAUTH_URL="$nextauth_url" \
             MEW_WEB_SERVICE="$MEW_WEB_SERVICE" MEW_BUILD_CONTEXT="$MEW_MAIN_DIR" && \
      docker compose -f "$_mew_compose_file" run --rm -e CI=1 "$MEW_WEB_SERVICE" sh -lc "$MEW_MIGRATE_CMD"
    ) || true
  fi
  # web 起動
  local build_rc=0
  (
    cd "$MEW_MAIN_DIR" && \
    export COMPOSE_PROJECT_NAME="$MEW_WT_PROJECT" WORKTREE_DIR="$target_dir" ENV_FILE="$env_file" \
           WEB_PORT="$MEW_WEB_PORT" DATABASE_URL="$database_url" NEXTAUTH_URL="$nextauth_url" \
           MEW_WEB_SERVICE="$MEW_WEB_SERVICE" MEW_BUILD_CONTEXT="$MEW_MAIN_DIR" && \
    docker compose -f "$_mew_compose_file" up -d "$MEW_WEB_SERVICE"
  ) || build_rc=$?
  _mew_cleanup_compose
  if ((build_rc != 0)); then
    echo "mew: web の起動に失敗しました (exit $build_rc)" >&2
    exit "$build_rc"
  fi
  # gitdir 内にマーカーを作成（シェルフックが docker compose → mew compose に置換するための目印）
  # .git/worktrees/<name>/mew に置くためブランチは汚れない
  if [[ "$MEW_IS_MAIN" != "true" && -f "$target_dir/.git" ]]; then
    local gitdir
    gitdir="$(sed -n 's/^gitdir: //p' "$target_dir/.git" 2>/dev/null)"
    if [[ -n "$gitdir" ]]; then
      [[ "$gitdir" != /* ]] && gitdir="$target_dir/$gitdir"
      touch "$gitdir/mew"
    fi
  fi
  echo "[mew] OK: http://localhost:$MEW_WEB_PORT"
}

# --- サブコマンド: rm ---
cmd_rm() {
  local root
  root="$(find_project_root .)"
  mew_resolve_context "$root" "$root"
  if [[ "${1:-}" == "--all" ]]; then
    shift
    cmd_rm_all "$root"
    return
  fi
  if [[ "$MEW_IS_MAIN" == "true" ]]; then
    echo "mew rm: main worktree では実行できません。引数で worktree パスを指定するか、全削除の場合は mew rm --all を main で実行してください。" >&2
    exit 1
  fi
  # この worktree のみ
  _mew_write_compose "$MEW_MAIN_DIR" "$MEW_WORKTREE_VOLUME_MOUNT"
  (
    cd "$MEW_MAIN_DIR" && \
    export COMPOSE_PROJECT_NAME="$MEW_WT_PROJECT" WORKTREE_DIR="$MEW_TARGET_WORKTREE_DIR" ENV_FILE="$MEW_ENV_FILE" MEW_WEB_SERVICE="$MEW_WEB_SERVICE" MEW_BUILD_CONTEXT="$MEW_MAIN_DIR" && \
    docker compose -f "$_mew_compose_file" down -v
  ) || true
  _mew_cleanup_compose
  if [[ -z "${KEEP_DB:-}" ]]; then
    local db_container_id
    db_container_id="$(cd "$MEW_MAIN_DIR" && docker compose ps -q "$MEW_DB_SERVICE")"
    if [[ -n "${db_container_id:-}" ]]; then
      docker exec -i \
        -e "MEW_DB_NAME=$MEW_WORKTREE_DB_NAME" \
        "$db_container_id" sh -l <<'DBSCRIPT' || true
psql -U "$POSTGRES_USER" -d postgres -v ON_ERROR_STOP=1 -c "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = '$MEW_DB_NAME';"
psql -U "$POSTGRES_USER" -d postgres -v ON_ERROR_STOP=1 -c "DROP DATABASE IF EXISTS \"$MEW_DB_NAME\";"
DBSCRIPT
    fi
  fi
  echo "[mew] rm done (worktree の削除は手動で: git worktree remove <path>)"
}

cmd_rm_all() {
  local root="$1"
  mew_resolve_context "$root" "$root"
  if [[ "$MEW_IS_MAIN" != "true" ]]; then
    echo "mew rm --all: main worktree で実行してください。" >&2
    exit 1
  fi
  local worktrees=()
  while IFS= read -r p; do
    [[ -n "$p" && "$p" != "$MEW_MAIN_DIR" ]] && worktrees+=("$p")
  done < <(git worktree list --porcelain 2>/dev/null | awk '/^worktree /{print $2}')
  if ((${#worktrees[@]} == 0)); then
    echo "[mew] worktree が他にありません。"
    return 0
  fi
  if [[ "${MEW_NON_INTERACTIVE:-}" != "1" ]]; then
    echo "以下を削除します: ${worktrees[*]}"
    read -r -p "続行しますか？ [y/N] " ans
    [[ "${ans:-N}" != [yY] ]] && exit 0
  fi
  for wt_dir in "${worktrees[@]}"; do
    [[ ! -d "$wt_dir" ]] && continue
    local slug wt_project
    slug="$(sanitize_slug "$(basename "$wt_dir")")"
    wt_project="$slug"
    local wt_db
    wt_db="$(db_name_for_slug "$slug" "$MEW_DB_NAME_PREFIX")"
    validate_db_name "$wt_db"
    _mew_write_compose "$MEW_MAIN_DIR" "$MEW_WORKTREE_VOLUME_MOUNT"
    (
      cd "$MEW_MAIN_DIR" && \
      export COMPOSE_PROJECT_NAME="$wt_project" WORKTREE_DIR="$wt_dir" ENV_FILE="$MEW_ENV_FILE" MEW_WEB_SERVICE="$MEW_WEB_SERVICE" MEW_BUILD_CONTEXT="$MEW_MAIN_DIR" && \
      docker compose -f "$_mew_compose_file" down -v
    ) || true
    _mew_cleanup_compose
    local db_container_id
    db_container_id="$(cd "$MEW_MAIN_DIR" && docker compose ps -q "$MEW_DB_SERVICE")"
    if [[ -n "${db_container_id:-}" && -z "${KEEP_DB:-}" ]]; then
      docker exec -i \
        -e "MEW_DB_NAME=$wt_db" \
        "$db_container_id" sh -l <<'DBSCRIPT' || true
psql -U "$POSTGRES_USER" -d postgres -v ON_ERROR_STOP=1 -c "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = '$MEW_DB_NAME';"
psql -U "$POSTGRES_USER" -d postgres -v ON_ERROR_STOP=1 -c "DROP DATABASE IF EXISTS \"$MEW_DB_NAME\";"
DBSCRIPT
    fi
    git worktree remove --force "$wt_dir" 2>/dev/null || true
  done
  echo "[mew] rm --all done"
}

# --- エントリ ---
main() {
  need_cmd git
  need_cmd docker

  local sub="${1:-}"
  shift 2>/dev/null || true
  case "$sub" in
    build)   cmd_build "$@";;
    compose) cmd_compose "$@";;
    rm)      cmd_rm "$@";;
    -h|--help|help|"") cmd_help;;
    -v|--version) echo "mew $VERSION";;
    *)
      echo "mew: 未知のサブコマンド: $sub" >&2
      cmd_help >&2
      exit 1
      ;;
  esac
}

main "$@"
